#lang racket

;List of numbers used in Countdown Game
(define numbList (list 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 25 50 75 100))

;Generate Random Number between 101 and 999
;define rand function, call the "random" library function, give it range min max.
(define rand
  (random 101 1000))


;Generate Random number with user input: Min/Max
(define (inp-rand x y)
 (random x y))

;make list of all basic arithmetic operations
;permutate all basic arithmetic operations
(define operList '(+ - / *))
(define arithmetic-op
  (permutations operList))

;[1]
;Select random element from a list.
;define list "rand-element".
;Get the length of our list, using "random" library function get the random element from the list.
;Using "list-ref" library function we return element from list of numbers "list" at a position generated by "random" function.
; https://docs.racket-lang.org/guide/set_.html
; If the list is empty set it to null.
;Then assign using "set!". Call "randomNumber", using cons, "glue" the elements together and assign them to "randSix" using "set!"
; If the length of "randSix" list is = 6 set it to randSIx.
;Append elements from "rand-element" numbList to the "randSix" list.
;permutate the 6 elements required for the game.
(define randSix(list))
(define (rand-element (list numbList))
  (define randomNumber (list-ref list (random (length list))))
  (if(null? list)
     null
     (set! randSix(cons randomNumber list)))
  (if(null? list)
     null
     (set! list (remq randomNumber list)))
  (if(= 6(length randSix))
     randSix
     (append list(rand-element list)))
  (permutations randSix)
  )

;get 6 numbers
;Run: (rand-element)
;type: randSix - will return 6 numbers stord in randSix list.

;;https://docs.racket-lang.org/htdp-langs/beginner.html
;http://stackoverflow.com/questions/4174839/random-function-in-scheme



;[2]: to be connected later after few fixes
;temporary numList (this will come from above rand generated 6 nums)
(define numList (list 1 2 3 4 5 6))
;temp operator list (to be done: permutations of cartesian product)
(define opList '(+ - * / +))
;temp permutation of numList
(define l (permutations numList))

;temp target number
(define tarNum 6)

;Generating 5 operators from a list of 4 using cartesian-product
(define ops '(+ - / *))

(define all-ops(cartesian-product ops ops ops ops ops))

;counter to check if it's going accordingly to calculation
(define counter 0)

(define ns (make-base-namespace))

;below i'm defining an equation in format of:
; (+ (/ (* (- (+ 1 2) 3) 4) 5) 6)

(define (equation permList)
 (if (null? permList)
     0
     (printf "...")
     ;(opseq all-ops permList)
  )
)

(define (opseq all-ops permList)
 (if (null? all-ops)
    0
    (begin
      (if (=
           (eval
            (quasiquote
             ((unquote(list-ref(list-ref all-ops 4)4))
              ((unquote(list-ref(list-ref all-ops 3)3))
               ((unquote(list-ref(list-ref all-ops 2)2))
                ((unquote(list-ref(list-ref all-ops 1)1))
                 ((unquote(list-ref(list-ref all-ops 0)0))
                  (unquote(list-ref (list-ref permList 0) 0))
                  (unquote(list-ref (list-ref permList 0) 1)))
                 (unquote(list-ref (list-ref permList 0) 2)))
                (unquote(list-ref (list-ref permList 0) 3)))
               (unquote(list-ref (list-ref permList 0) 4)))
              (unquote(list-ref (list-ref permList 0) 5)))
             ) ns) tarNum)        
       (set! counter (+ 1 counter))
       0
      )
      (opseq (cdr all-ops) (cdr permList))
     )
 )
)


;running equation function with permutations of permList (l)
(equation l)
;counter to see if it's correct.
counter


;evaluating the equation (this specific version will equal to 0 and so it does)
;(eval string ns)
;saying what the string func evaluates
;(quasiquote (string is equal to: (unquote (eval string ns))))


