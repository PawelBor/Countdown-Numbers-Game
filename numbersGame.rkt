#lang racket

;List of numbers used in Countdown Game
(define numList (list 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 25 50 75 100))

;Generate Random Number between 101 and 999
;define rand function, call the "random" library function, give it range min max.
(define tarNum
  (random 101 1000))


;Generate Random number with user input: Min/Max
(define (inp-rand x y)
 (random x y))

;[1]
;Select random element from a list.
;define list "rand-element".
;Get the length of our list, using "random" library function get the random element from the list.
;Using "list-ref" library function we return element from list of numbers "list" at a position generated by "random" function.
; https://docs.racket-lang.org/guide/set_.html
;Call "randomNumber", using cons, "glue" the elements together and assign them to "randSix" using "set!"
; If the length of "randSix" list is = 6 set it to randSIx, else repeat process.
(define randSix(list))
(define (rand-element list)
  (define randomNumber (list-ref list (random (length list))))
     (set! randSix(cons randomNumber randSix))
     (set! list (remq randomNumber list))
  (if(= 6(length randSix))
     randSix
     (rand-element list))
  )

(quasiquote (Six Random Numbers: (unquote (rand-element numList)) Target Number: (unquote tarNum)))

;;https://docs.racket-lang.org/htdp-langs/beginner.html
;http://stackoverflow.com/questions/4174839/random-function-in-scheme



;[2]
;temp permutation of randSix (contains 6 random numbers from numList)
(define l (permutations randSix))

;Generating 5 operators from a list of 4 using cartesian-product
(define ops '(+ - / *))

(define all-ops(cartesian-product ops ops ops ops ops))

;counter to check if it's going accordingly to calculation
(define equationCount 0)

(define ns (make-base-namespace))

(define accuList null)
(define equationList null)

;below i'm defining an equation in format of:
; (+ (/ (* (- (+ 1 2) 3) 4) 5) 6)

(define (equation permList operators aList tNum)
 (if (null? permList)
     0
     (begin 
      (opseq operators permList aList tNum)
      (equation (cdr permList) operators aList tNum)
      )
  )
)

(define (opseq all-ops permList aList tNum)
 (if (null? all-ops)
    0
    (begin
      (set! equationCount (+ 1 equationCount))
      (set! equationList (quasiquote
             ((unquote(list-ref(list-ref all-ops 0)4))
              ((unquote(list-ref(list-ref all-ops 0)3))
               ((unquote(list-ref(list-ref all-ops 0)2))
                ((unquote(list-ref(list-ref all-ops 0)1))
                 ((unquote(list-ref(list-ref all-ops 0)0))
                  (unquote(list-ref (list-ref permList 0) 0))
                  (unquote(list-ref (list-ref permList 0) 1)))
                 (unquote(list-ref (list-ref permList 0) 2)))
                (unquote(list-ref (list-ref permList 0) 3)))
               (unquote(list-ref (list-ref permList 0) 4)))
              (unquote(list-ref (list-ref permList 0) 5)))
             ))
      (if (= (eval equationList ns) tNum)
          (opseq (cdr all-ops) permList (set! accuList (cons equationList accuList)) tNum)
          (opseq (cdr all-ops) permList aList tNum)))))

(equation l all-ops accuList tarNum)

(quasiquote (All possible equation for Target Number: (unquote tarNum)))
accuList
(quasiquote (Brute-Force: Total equations: (unquote equationCount)))
(quasiquote (There are: (unquote (length accuList)) possible equations for Target Number:(unquote tarNum)))



